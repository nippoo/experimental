<!DOCTYPE html>
<meta charset="utf-8">
<script src="d3.js"></script>

<link rel="stylesheet" href="clusterviewd3.css">

<div id="cv"></div>
<p id="sortby">Changing this will trigger an update<select></select></p>

<script>
// Test functions
function random_number(min,max)
{
    return (Math.round((max-min) * Math.random() + min));
}

function generate_random_cluster_info(num)
{

    var bins = [];
    var nbins = 11; // must be odd!

    bins[0] = 0
    bins[nbins] = 0

    for (var element=1; element<nbins/2; element++) {
        var binval = random_number(0,120);
        bins[element] = binval;
        bins[nbins-element] = binval;
    }

    var clusterInfo = {
            id: num,
            quality: Math.random(),
            nchannels: random_number(10, 1000),
            nspikes: random_number(500, 1000000),
            ccg: bins,
            selected: false
    };

    return clusterInfo;
}

function generate_all_clusters()
{
    var clusters = []
    var nclusters = 5

    for (var i = 3; i <= nclusters; i++)
    {
        clusters.push(generate_random_cluster_info(i));
    }

    return clusters;
}

</script>

<script>

function redraw()
{
//
// Clusters entering the view
//
    var cluster = d3.select("#cv").selectAll(".cluster")
            .data(clusters, function(d) { return d.id; });

    var clusterEnter = cluster.enter()
                            .insert("div")
                            .attr("class", function (d) {return (d.selected) ? "cluster sel" : "cluster";})
                            .style("fill-opacity", 0)
                            .on('mousedown', function(d) {
                                clusterClicked(d, this);
                            });

    var lineFunction = d3.svg.line()
                         .x(function(d, i) { return width-(i*barWidth); })
                         .y(function(d, i) { return height-d; })
                         .interpolate("step-after");

    var svgContainer = clusterEnter.append("svg")
                        .attr("width", width)
                        .attr("height", height);


    svgContainer.append("path")
                .datum(function(d) {barWidth = width/d.ccg.length; return d.ccg;})
                .attr("d", function(d) {return lineFunction(d)})
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "black")

    clusterEnter.append("div")
        .text(function(d) { return d.id; });

    clusterEnter.append("div")
        .text(function(d) { return d.nchannels + "ch"; });

//
// Clusters to update
//

    var clusterUpdate = d3.transition(cluster)
      .style("fill-opacity", 1)
      .attr("class", function (d) {return (d.selected) ? "cluster sel" : "cluster";});
//
// Clusters to remove
//

    var clusterExit = d3.transition(cluster.exit())
        .style("fill-opacity", 0)
        .remove();
}

function clusterClicked(d, node) {

    cls = d3.selectAll('.cluster')

    // first, deal with selection ranges
    if (d3.event.shiftKey) {
        var firstSelectedIndex, lastSelectedIndex, currentIndex;

            cls.each(function(dl, i) {
            if (dl.selected) {
              firstSelectedIndex || (firstSelectedIndex = i);
              lastSelectedIndex = i;
            }
            if (this === node) currentIndex = i;
          });
          var min = Math.min(firstSelectedIndex, lastSelectedIndex, currentIndex);
          var max = Math.max(firstSelectedIndex, lastSelectedIndex, currentIndex);

          // select all between first and last selected
          // when clicked inside a selection
          cls.each(function(d, i) {

            // preserve state for additive selection
            d.selected = ((d3.event.ctrlKey || d3.event.metaKey) && d._selected) || (i >= min && i <= max);
          });
        }
    else
    {
      // additive select with `ctrl` key
      if (!(d3.event.ctrlKey || d3.event.metaKey)) {
        cls.each(function(d) { d.selected = false; });
      }
      d.selected = !d.selected;
    }

    redraw();
}

function change() {
    d3.transition(500)
        .each(redraw);
}

</script>


<script>
// Start page load
console.time("pageLoadTime");

var width = 110,
height = 110;

clusters = generate_all_clusters();

var menu = d3.select("#sortby select")
    .on("change", change);

redraw();

menu.selectAll("option")
    .data(clusters)
    .enter().append("option") // TODO: return the labels inside one object...
    .text(function (d) { return d.clusternumber; });

console.timeEnd("pageLoadTime");
</script>

</html>
