<!DOCTYPE html>
<meta charset="utf-8">
<script src="d3.js"></script>

<link rel="stylesheet" href="clusterviewd3.css">

<div id="cv"></div>
<p id="sortby">Changing this will trigger an update<select></select></p>

<script>
// Test functions
function random_number(min,max)
{
    return (Math.round((max-min) * Math.random() + min));
}

function generate_random_cluster_info(num)
{

    var bins = [];
    var nbins = 41; // must be odd!

    bins[0] = 0
    bins[nbins] = 0

    for (var element=1; element<nbins/2; element++) {
        var binval = random_number(0,120);
        bins[element] = binval;
        bins[nbins-element] = binval;
    }

    var clusterInfo = {
            id: num,
            quality: Math.random(),
            nchannels: random_number(10, 1000),
            nspikes: random_number(500, 1000000),
            ccg: bins,
            selected: false
    };

    return clusterInfo;
}

function generate_all_clusters()
{
    var clusters = []
    var nclusters = 4

    for (var i = 0; i < nclusters; i++)
    {
        clusters.push(generate_random_cluster_info(i));
    }

    return clusters;
}

</script>

<script>

function redraw()
{
    var cluster = d3.select("#cv").selectAll(".cluster")
                    .data(clusters, function(d) { return d.id; });

//
// Clusters entering the view
//

    var clusterEnter = cluster.enter()
                            .insert("div")
                            .attr("class", function (d) {return (d.selected) ? "cluster sel" : "cluster";})
                            .style("fill-opacity", 0)
                            .on("click", clusterClicked);

    var lineFunction = d3.svg.line()
                         .x(function(d, i) { return width-(i*barWidth); })
                         .y(function(d, i) { return height-d; })
                         .interpolate("step-after");

    var svgContainer = clusterEnter.append("svg")
                        .attr("width", width)
                        .attr("height", height);


    svgContainer.append("path")
                .datum(function(d) {barWidth = width/d.ccg.length; return d.ccg;})
                .attr("d", function(d) {return lineFunction(d)})
                .attr("stroke", "black")
                .attr("stroke-width", 0)
                .attr("fill", "black")

    clusterEnter.append("div")
        .text(function(d) { return d.id; });

    clusterEnter.append("div")
        .text(function(d) { return d.nchannels + "ch"; });

//
// Clusters to update
//

    var clusterUpdate = d3.transition(cluster)
      .style("fill-opacity", 1)
      .attr("class", function (d) {return (d.selected) ? "cluster sel" : "cluster";});
//
// Clusters to remove
//

    var clusterExit = d3.transition(cluster.exit())
        .style("fill-opacity", 0)
        .remove();
}

function clusterClicked(d, ev) {
    // If we're not doing a multi-selection here, then deselect all other elements first

    if( !(d3.event.metaKey) && !(d3.event.ctrlKey)) {
        d3.selectAll('.sel')
        .classed("sel", function(d){
            d.selected = false;
            return false;}
            );
        d.selected = !d.selected;
    }
    else {
        d.selected = true;
    }
    redraw();
}

function change() {

  d3.transition()
      .each(redraw);
}

</script>


<script>
// Start page load
console.time("pageLoadTime");

var width = 110,
height = 110;
clusters = generate_all_clusters();
redraw();

var menu = d3.select("#sortby select")
    .on("change", change);

menu.selectAll("option")
    .data(clusters)
    .enter().append("option") // TODO: return the labels inside one object...
    .text(function (d) { return d.clusternumber; });

console.timeEnd("pageLoadTime");
</script>

</html>
